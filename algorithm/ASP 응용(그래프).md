# ASP 응용

## 그래프

> * 그래프는 아이템(사물 or 추상적 개념)들과 이들 사이의 연결 관계를 표현한다.
> * 그래프는 정점들의 집합과 이들을 연결하는 간선들의 집합으로 구성된 자료 구조
>   * `|V|` : 정점의 개수, `|E|` : 그래프에 포함된 간선의 개수
>   * `|V|` 개의 정점을 가지는 그래프는 최대 `|V|(|V| - 1)/2` 간선이 가능
>     * ex) 5개의 정점이 있는 그래프의 최대 간선 수는 10(=5*4/2)개
> * 선형 자료구조나 트리 자료구조로 표현하기 어려운 `N:N` 관계를 가지는 원소들을 표현하기 용이



### 1. 그래프 순회(탐색)

#### 1.1 DFS(Depth First Search) : 깊이 우선 탐색



#### 1.2 BFS(Breadth First Search) : 너비 우선 탐색



### 2. 서로소 집합들(Disjoint-Sets)

> * 서로소 또는 상호배타 집합들을 서로 중복 포함된 원소가 없는 집합들.
>
>   -> 교집합이 없다.
>
> * 대표자(representative) : 집합에 속한 하나의 특정 멤버를 통해 각 집합들을 구분한다.
>
> * 상호배타 집합을 표현하는 방법
>
>   * 연결 리스트
>   * 트리

#### 2.1 상호배타 집합 연산

- Make-Set(x) : x라는 원소를 포함하는 집합을 만든다.

  ```python
  # 유일한 멤버 x를 포함하는 새로운 집합을 생성하는 연산
  # p[x] : 노드 x의 부모 저장
  # rank[x] : 루트 노드가 x인 트리의 랭크 값 저장
  
  def Make-Set(x):
  	p[x] = x
      rank[x] = 0
  ```

- Find-Set(x) : x라는 원소가 속한 집합을 찾아 대표자의 식별값을 알려준다.

  ```python
  # x를 포함하는 집합을 찾는 연산
  def Find-Set(x):
      if x != p[x]: # x가 루트가 아닌 경우
          p[x] = Find-Set(p[x])
      return p[x]
  ```

  > Find-Set 연산은 특정 노드에서 루트까지의 경로를 찾아가면서 노드의 부모 정보를 갱신한다.

- Union(x, y) : x가 속한 집합과 y가 속한 집합을 합치는 것.

  ```python
  # x와 y를 포함하는 두 집합을 통합하는 연산
  def Union(x, y):
      Link(Find-Set(x), Find-Set(y))
      
  def Link(x, y):
      if rank[x] > rank[y]: # rank는 트리의 높이
          p[y] = x
      else:
          p[x] = y
          if rank[x] == rank[y]:
              rank[y] += 1
  ```

* Disjoint Set 만드는 법:

  1) 집합 안에 있는 각각의 원소를 Make-Set을 사용하여 자신을 원소로 가지는 집합으로 형성

  2) Union을 사용하여 하나씩 연결

  3) 그 후 연결된 집합에서 대표값 탐색

  4) 2 ~ 3 반복

* Tree를 활용한  Disjoint Set

  * 구현시 부모 자식의 위치만 저장하는 방식
  * 트리의 루트값은 대표값!!
  * Union시에서는 둘 중 한쪽 루트의 부모 값을 다른 노드 값으로 연결

* Path Compression

  * Find-Set을 진행할 때 합치는 아이의 서브트리의 부모를 합쳐지는 아이의 루트값으로 설정한다.



### 3. 최소신장트리(MST)

> * 그래프에서 최소 비용 문제
>   * 모든 정점을 연결하는 간선들의 가중치의 합이 최소가 되는 트리
> * 신장 트리
>   * n개의 정점으로 이루어진 무향 그래프에서 n개의 정점과 n-1개의 간선으로 이루어진 트리
> * 최소신장트리(Minimum Spanning Tree)
>   * 무향 가중치 그래프에서 신장 트리를 구성하는 간선들의 가중치의 합이 최소인 신장 트리

* MST 표현
  * 그래프
  * 간선들의 배열
  * 인접 리스트
  * 부모 자식관계와 가중치에 대한 배열

#### 3.1 KRUSKAR  알고리즘

> 간선을 하나씩 선택해서 MST를 찾는 알고리즘
>
>   1) 최초, 모든 간선을 가중치에 따라 **오름차순**으로 정렬
>
>   2) 가중치가 가장 낮은 간선부터 선택하면서 트리를 증가시킴
>
> ​		- 사이클이 존재하면 다음으로 가중치가 낮은 간선 선택
>
>   3) n - 1 개의 간선이 선택될 때까지 `2)` 반복

* 알고리즘

  ```python
  def mstKruskal(g, w):
      a = 0 	# 0 : 공집합
      for v in gv:	# GV : 그래프의 정점 집합
          make-Set(v)		# GE : 그래프의 간선 집합
          
      # GE에 포함된 간선들을 가중치 w에 의해 정렬
          
      for 가중치가 가장 낮은 간선 (u, v) ∈ GE 선택(n-1개):
          if find-Set(u) != find-Set(v):
              A = A ∪ {(u, v)}
              Union(u, v)
      
      return A
          
  ```

#### 3.2 Prim 알고리즘

> 하나의 정점에서 연결된 간선들 중에 하나씩 선택하면서 MST를 만들어가는 방식
>
>   1) 임의의 정점을 하나 선택해서 시작
>
>   2) 선택한 정점들과 인접하는 정점들 중의 최소 비용의 간선이 존재하는 정점을 선택
>
>   3) 모든 정점이 선택될 때까지 `1)` , `2)` 과정을 반복
>
> 서로소인 2개의 집합(2 disjoint-sets) 정보를 유지
>
> * 트리의 정점들(tree vertices) : MST를 만들기 위해 선택된 정점들
> * 비트리 정점들(non-tree vertices) : 선택 되지않는 정점들

#### 3.3 BFS에서 MST구하기

* 간선 완화(Edge Relaxation)
  * 간선있는 그래프에서 특정 그래프에 도착했을때의 가중치합이 이전에 도착했을때의 가중치 합보다 작을(클) 경우 현재의 가중치 합으로 변경하는것.



### 4. 최단경로

> * 간선의 가중치가 있는 그래프에서 두 정점 사이의 경로들 중에 간선의 가중치의 합이 최소인 경로
> * single-source : 하나의 시작 정점에서 끝 정점까지의 최단 경로
>   * 다익스트라(dijkstra)알고리즘
>     * 음의 가중치를 허용 X
>   * 벨만-포드(Bellman-Ford) 알고리즘
>     * 음의 가중치 허용
> * shortest-path : 모든 정점들에 대한 최단 경로 알고리즘
>   * 플로이드- 워샬(Floyd-Warshall) 알고리즘

#### 4.1  Dijkstra 알고리즘

> * 시작 정점에서 거리가 최소인 정점을 선택해 나가면서 최단 경로를 구하는 방식이다.
> * 시작정점(s) 에서 끝정점(t)까지의 최단 경로에 정점 x가 존재한다. 이때, 최단경로는 s에서 x까지의 최단 경로와 x에서 t까지의 최단경로로 구성된다.
> * 탐욕기법을 사용한 알고리즘으로 MST의 프림 알고리즘과 유사.

```python
# s : 시작 정점, A : 인접 행렬, D : 거리
# V : 정점 집합, U : 선택된 정점 집합
def Dijkstra(s, A, D):
    U = {s}
    D = [0xfffff] * (len(V) + 1)
    D[0] = 0
    for 모든 정점 v:
        D[v] = A[s][v]
        
    while V != U:
        D[w]가 최소인 정점 w ∈ V - U를 선택
        U = U ∪ {w}
        
        for w에 인접한 모든 정점 v:
            D[v] = min(D[v], D[w] + A[w][v])
```

