# ASP 기본

## 리스트

#### [list_class](C:\Users\student\Desktop\Jimin\algorithms\project\190902)

### 1.1 리스트

> 순서를 가진 데이터의 집합을 가르키는 추상자료형

#### 1.1.1 순차 리스트

> 배열 기반(1차원 배열에 항목들을 순서대로 저장하여 인덱스를 이용해 접근)

* **삽입 연산** : 삽입 위치 다음의 항목들을 이동해야 한다.
* **삭제 연산** : 삭제 위치 다음의 항목들을 이동
* 단점 : 계속 원소들을 이동시키는 작업이 필요하다. (메모리 및 시간 낭비)

#### 1.1.2 연결 리스트 ( Linked List )

> 메모리 동적할당을 기반
>
> 자료의 논리적인 순서와 메모리 상의 물리적 순서가 일치하지 않고, 개별적으로 위치하고 있는 원소의 주소를 연결하여 하나의 전체적인 자료구조를 이룬다. 링크를 통해 원소에 접근하며, 자료구조의 크기를 동적으로 조정할 수 있다.

* **노드** (연결리스트에서 하나의 원소에 필요한 데이터의 자료단위)

  * 구성요소

    1) 데이터 필드

    * 원소의 값을 저장하는 자료구조
    * 저장할 원소의 종류나 크기에 따라 구조를 정의하여 사용

    2) 링크 필드

    * 다음 노드의 주소를 저장하는 자료구조

* **헤드** (리스트의 처음 노드를 가리키는 레퍼런스)

##### 1.1.2.1 단순 연결 리스트

* **연결구조**

  * 노드가 하나의 링크 필드에 의해 다음 노드와 연결되는 구조
  * 헤드가 가장 앞의 노드를 가리키고, 링크 필드가 연속적으로 다음 노드를 가리킨다.
  * 최종적으로 NULL을 가리키는 노드가 리스트의 가장 마지막 노드이다.

* **삽입 연산**

  1) 메모리를 할당하여 새로운 노드 생성

  2) 새로운 노드의 데이터 필드에 값 저장

  3) 삽입될 위치의 바로 앞의 노드의 링크 필드를 new에 복사

  4) new의 주소를 앞 노드의 링크 필드에 저장

* **삭제 연산**

  1) 삭제할 노드의 앞 노드(선행노드) 탐색

  2) 삭제할 노드의 링크 필드를 선행노드의 링크 필드에 복사

##### 1.1.2.2 이중 연결 리스트

* **연결구조**

  * 양쪽 방향으로 순회할 수 있도록 노드를 연결한 리스트
  * 두 개의 링크 필드와 한 개의 데이터 필드로 구성

* **삽입 연산**

  1) 메모리를 할당하여 새로운 노드 new를 생성하고 데이터 필드에 값 저장

  2) 삽입할 위치 전의 노드의 next를 new의 next에 저장하여 new와 뒷 노드를 연결

  3) new의 주소를 삽입할 위치 전 노드의 next에 저장하여 new와 앞 노드를 연결

  4) 앞 노드의 링크 값을 new의 prev에 저장하여 앞노드와 연결

  5) new의 주소를 뒷 노드의 prev에 저장하여 뒷노드와 연결

* **삭제 연산**

  

### 1.2 삽입 정렬(Insertion Sort)

* **정렬 과정**

  * 정렬할 자료를 두개의 부분집합 S와 U로 가정

    `부분집합 S` : 정렬된 앞부분의 원소들

    `부분집합 U` : 아직 정렬되지 않은 원소들

  * 정렬되지 않은 부분집합 U의 원소를 하나씩 꺼내서 이미 정렬된어 있는 부분집합 S의 마지막 원소부터 비교하면서 삽입

  * 부분집합 U가 공집합이 되면 삽입정렬 완성

* 시간 복잡도 = O(n^2)



### 1.3 병합 정렬(Merge Sort)

> 여러개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 방식

* 분할 정복 알고리즘 활용

  * 자료를 최소 단위의 문제까지 나눈 후에 차례대로 정렬하여 최종 결과를 얻어냄
  * top-down 방식

  

### 1.4 리스트를 이용한 스택

> 스택의 원소 : 리스트의 노드 (스택 내의 순서는 리스트의 링크를 통해 연결됨)
>
> 변수 `top` : 리스트의 마지막 노드를 가리키는 변수 (초기상태 : `top = null`)

* `Push` 와 `Pop` 연산 구현

  1) `null` 값을 가지는 노드를 만들어 스택 초기화

  2) `push`

  3) `pop`

  

### 1.5 우선순위 큐(Priority Queue)

> 기본연산 : 삽입(enQueue), 삭제(deQueue)



#### 1.5.1 배열을 이용한 우선순위  큐

> 배열을 이용하여 자료 저장으로 삽입과정에서 우선순위를 비교하여 적절한 위치에 삽입하는 구조
>
> 가장 앞에 최고 우선순위의 원소가 위치

* 문제점 : 배열을 사용하므로, 삽입 및 삭제 연산시 윈소의 재배치 발생



#### 1.5.2 리스트를 이용한 우선순위 큐

> 연결 리스트를 이용하여 자료 저장하여, 원소를 삽입하는 과정에서 리스트 내 노드의 원소들과 비교하여 적절한 위치에 노드를 삽입하는 구조
>
> 리스트의 가장 앞쪽에 최고 우선순위가 위치

* 배열 대비 장점
  * 삽입/삭제 연산 이후 원소의 재배치가 필요 없음
  * 메모리의 효율적 사용

