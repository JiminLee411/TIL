# ASP 기본

## 스택(Stack)

> - 선형구조 (LIFO - 후입선출)
> - 자료구조 : 자료를 선형으로 저장할 저장소
> - 연산
>   - 삽입(push), 삭제(pop), 공백확인(isEmpty), 스택의 top의 item 반환(peek)
> - `Fucntion call` : 함수 호출마다 함수의 지역변수, 매개변수 및 복쉬주소 등의 정보를 시스템 스택에 삽입.

### 1. 재귀호출

- 재귀적으로 문제를 해결
  - 좀 더 작은 문제의 해를 이용해서 좀 더 큰 문제의 해를 구하는 과정 
    - 분할정복, DP

### 2. Memoization

- 재귀 호출의 단점인 같은 수를 여러번 호출 하는것을 방지

### 3. DP(Dynamic Programming)

- 작은 문제의 해를 해격하여 큰 문제를 해결하는 방식으로 최적화 문제를 해결
- **푸는 순서를 찾는것이 핵심 **

### 4. DFS

#### 4.1 그래프

> 그래프 : 아이템들과 이들 사이의 연결관계

- 자료 구조 :  `정점(Vertex)` + `간선(Edge)` 
  - |V| : 정점의 개수
  - |E|: 그래프에 포함된 간선의 개수
  - 최대 간선의 개수 : |V| * (|V| - 1) / 2
- 그래프 유형
  - 무향 그래프(Undirected Graph)
  - 유향 그래프(Directed Graph)
  - 가중치 그래프(Weighted Graph)
  - 사이클 없는 방향 그래프(DAG, Directed Acyclic Graph)
  - 완전 그래프 : 정점들에 대해 가능한 모든 간선을 가진다.
  - 부분 그래프 : 원래 그래프에서 일부의 정점이나 간선을 제외한 그래프

##### 4.1.1 인접 정점

- 인접(Adjacency) :  두개의 정점에 간선이 존재하면 서로 인접해 있다고 한다.

##### 4.1.2 그래프 표현

- 인접 행렬 (Adjacent matrix) 
  - |V| x |V|크기의 2차원 배열을 이용해서 간선 정보를 저장
  - 무향 그래프 : i번째 행의 합 = i번째 열의 합 = Vi의 차수
  - 유향 그래프
    - 행 i의 합 = Vi의 진출 차수
    - 열 i의 합 = Vi의 진입 차수
  - 인접 정점을 찾는데 시간 소모 많다.
- 인접 리스트 (Adjacent LIst)
  - 각 정점에 대한 인접 정점들을 순차적으로 펴현
  - 하나의 정점에 대한 인접 정점들을 각각 노드로 하는 연결리스트로 저장
  - 무향 그래프
    - 노드수 = 간선 수 * 2
    - 각 정점의 노드 수 = 정점의 차수
  - 유향 그래프
    - 노드수 = 간선의 수
    - 각정점의 노드 수 = 정점의 진출 차수
- 간선의 배열
  - 간선(시작 정점, 끝 정점)을 배열에 연속으로 저장
- 비선형구조인 그래프 구조는 그래프로 표현된 모든 자료를 검색해야함
  - 방법
    - DFS
    - BFS

#### 4.2 DFS(깊이우선탐색)

- DFS 알고리즘
  1. 시작 정점 `v`를 결정하여 방문
  2. 정점 `v` 에 인접한 정점중에
     - 방문하지 않은 정점 `w` 가 있으면, 정점 `v`를 스택에 push하고 정점 `w` 를 방문한다. 그리고 `w`를 `v`로 하여 다시 **2.**를 반복한다.
     - 방문하지 않은 정점이 없으면, 탐색의 방향을 바꾸기 위해서 스택을 pop하여 받은 가장 마지막 방문 정점을 `v`로 하여 다시 **2.**를 반복한다.
  3. 스택이 공백이 될 때까지 **2.**를 반복한다.
- 단점
  - 출발점부터 정점까지 최단경로로 간다고 보장 X

### 5. 계산기

중위표현식 -> 후위표현식으로 변경

### 6. 백트래킹

- 백트래킹 : 해를 찾는 도중에 막히면 되돌아가서 다시 해를 찾아가는 기법

  -> 최적화(optimization) 문제와 결정(decision) 문제를 해결할 수 있다.

- 결정문제 : 문제의 조건을 만족하는 해의 존재 여부를 '1' or '0'으로 답하는 문제

  - 미로찾기, n-Queen 문제, Map colring, 부분집합의 합
    - 깊이우선탐색 : 모든 경로 추적 -> 경우의 수 많음
    - 백트래킹 : 불필요한 경로 조기 차단 -> 최악의 경우에는 깊이우선탐색과 동일.

- 일반 백트래킹 알고리즘

  ```python
  def checknode(v): # node
      if promising(v):
          if there is a solution at v:
              write the solution
          else:
              for u in each child of v:
                  checknode(u)
  ```

  

### 7. 분할정복

- 설계 전략
  - 분할(Divide)
  - 정복(Conqure)
  - 통합(Combine)

