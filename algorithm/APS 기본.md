# APS 기본

## 1. 배열 1( Array 1)

* **알고리즘** : 문제를 해결하기 위한 절차. ( 텍스트 기반, 순서도 )

  * 정확성 : 결과의 정확성

  * 작업량 : 적은 연산을 통한 결과

    * 시간복잡도(Time Complexity) : 실제 걸리는 시간을 측정, 실행되는 명령문의 개수를 계산

    * 시간복잡도 : 가장 높은 차수의 항만 표시.

      ​	빅-오(O(n)) : 최악의 경우 ( 마지막에 성공하거나 실패하는 경우)

      ​	오메가(Ω(n)) : 최선의 경우 ( 첫번째에 성공)

      ​	씨타() : 빅-오와 오메가가 같을 경우

    * 순차 검색 : 처음부터 끝까지 검색하며 나간다.

    * 이진 검색: 임의의 숫자부터 검색을 하여 검색할 곳을 반으로 줄여나간다.

  * 메모리 사용량 : 적은 메모리 이용

  * 단순성 : 간단한 알고리즘

  * 최적성 : 개선 필요 없는 최적화

    

* **배열** : `동일한 자료형`의 변수들을 하나로 저장하여 사용하는 자료구조 / 인덱스 기반 데이터 처리

  * c : 동일한 자료형으로 만들어야 자료형의 크기에 맞게 인덱스로 찾아갈수 있다.
  *  파이썬 : list는 그냥 배열이 아닌 포인터 배열이다. `포인터 배열`로 각 방에는 `각 데이터의 주소값`이 저장돼있으므로 일정하 크기의 값을 가지고있어 인덱스로 찾아갈 수 있다. 

  

* **정렬** : 2개 이상의 자료를 특정 기준에 의해 재배열하는 것

  

  1. 버블 정렬 (Bubble Sort) 

     * 인접한 두개의 원소를 비교하며 자리를 교환
     * 시간복잡도 : O(n^2)

     ```python
     arr = [55, 7, 78, 12 ,42]
     n = len(arr)
     
     for j in rnage(n - 1, 0 , -1):
     	for i in range(j): # n - 1 ~ 1만금 반벅
         	if arr[i] > arr[i + 1]:
             	arr[i], arr[i + 1] = arr[i + 1], arr[i]
                 
     print(arr)
     ```

     

  2. 카운팅 정렬 ( Counting Sort)

     * 항목의 순서 결정을 위해 각 항목이 몇개 있는지 세는 작업
     * 양의 정수만 적용 가능. 또한, 최대값을 알고있어야 한다.(배열의 크기를 선언하기 위해)
     * 시간복잡도 : O(n + k) -> n은 리스트 길이, k는 정수의 최대값

     ```python
     arr = [0, 4, 1, 3, 1, 2, 4, 1]
     # 양의 정수, 최대값을 알아야 된다.
     # 최대값 = 4
     cnt = [0] * 5 # 배열의 인덱스 n-1 = 4
     
     # 빈도수 계산
     for val in arr:
         cnt[val] += 1  # cnt = [1, 3, 1, 1, 2]
         
     # 누적 빈도수 계산 - 정렬을 하기 위한 각 숫자의 마지막 숫자의 위치를 구해준다
     for i in range(1, len(cnt)):
         cnt[i] = cnt[i - 1] + cnt[i] # cnt = [1, 4, 5, 6, 8]
         
     # 구한 누적빈도수로 빈리스트에 숫자를 옮겨 준다.
     for i in range(cnt[-1]-1):
         cnt[i]
         res[cnt[i-1]]
         
         
     print(cnt)
     ```

     ```python
     res = []
     arr = [0, 4, 1, 3, 1, 2, 4, 1]
     # 양의 정수, 최대값을 알아야 된다.
     # 최대값 = 4
     cnt = [0] * 5 # 배열의 인덱스 n-1 = 4
     
     # 빈도수 계산
     for val in arr:
         cnt[val] += 1  # cnt = [1, 3, 1, 1, 2]
     
     for i in ragne(len(cnt)):
         for j in range(cnt[i]):
             # i가 cnt[i] 만큼 반복되는 것
             res.append(i)
     print(res)
     ```

* 연습문제

  ```python
  # 배열 활용 예제 : Gravity
  # 밑에서부터 쌓이므로 제일 위에 있는 블럭만 비교하면 된다.
  # 그 후 해당 index의 값과 같거나 큰 index와의 index의 차를 구하면 된다.
  ```

  - 결정 문제

  ```python
  # Baby-gin Game
  # 1. 완전 검색 방법
  # 6장 중 3장씩 두 그룹으로 나눠서 모든 경우를 체크해보고 baby-gin이 있으면 true
  
  #
  ```

  

* **완전 검색**

  * 문제의 해법의 모든 경우의 수를 나열해보고 확인
  * Brute-force 혹은 generate-and-test 기법
  * 최적화 문제 : 최적해를 구하는 문제(최소 혹은 최대가 되는 경우를 찾고 모든 후보해를 조사.)
    - 따져봐야할 경우의 수 : 순열(n!), 조합, 부분집합(2^n) -> 완전탐색
    - 해결법 : 탐색기반 - 백트래킹 + (가지치기) / BP : 문제간의 관계(재귀적관계)동적 계획법





## 2. 배열 2 ( Array 2)



## 3. 문자열 (stirng)





## 4. 스택1



## 5. 스택2





## 6. 큐(Queue)



## 7. 리스트(list)



## 8. 트리

