# ASP 기본

## 배열

> 동일한 자료형의 변수들을 하나로 저장하여 사용하는 자료구조 / 인덱스 기반 데이터 처리

* c : 동일한 자료형으로 만들어야 자료형의 크기에 맞게 인덱스로 찾아갈수 있다.
* 파이썬 : list는 그냥 배열이 아닌 포인터 배열이다.  *포인터 배열* 로 각 방에는 <u>각 데이터의 주소값</u>이 저장돼있으므로 일정하 크기의 값을 가지고있어 인덱스로 찾아갈 수 있다. 

### 1. 정렬

> 2개 이상의 자료를 특정 기준에 의해 재배열하는 것

#### 1.1 버블 정렬 (Bubble Sort)

* 인접한 두개의 원소를 비교하며 자리  교환
* 시간복잡도 : O(n^2)

```python
arr = [55, 7, 78, 12, 42]
n = len(arr)

for i in range(n - 1, 0, -1):
    for j in range(i):
        if arr[j + 1] < arr[j]:
            arr[j], arr[j + 1] = arr[j + 1], arr[j]
            
print(arr)
```

#### 1.2. 카운팅 정렬(Counting Sort)

* 항목이 몇개 있는지 세는 작업
* 양의 정수만 적용 가능, 최대값을 알고 있어야한다.(배열의 크기를 선언하기 위해)
* 시간복잡도 : O(n + k) - n : 리스트 길이, k : 정수의 최대값

```python
res = []
arr = [0, 4, 1, 3, 1, 2, 4, 1]
# 양의 정수, 최대값을 알아야 된다.
# 최대값 = 4
cnt = [0] * 5 # 배열의 인덱스 n-1 = 4

# 빈도수 계산
for val in arr:
    cnt[val] += 1  # cnt = [1, 3, 1, 1, 2]

for i in ragne(len(cnt)):
    for j in range(cnt[i]):
        # i가 cnt[i] 만큼 반복되는 것
        res.append(i)
print(res)
```

#### 1.3 완전 검색

> 문제의 해법의 모든 경우의 수를 확인

* Brute-force 혹은  generate-and-test 기법
* 최적화
  * 탐색기반 : 백트래킹 + DP



### 2. 2차원 배열

- 1차원 리스트를 묶어놓은 리스트

- 2차원 이상의 다차원 list는 차원에 따라 index를 선언

- 2차원 list의 선연 : 세로길이(행의 개수), 가로길이(열의 개수) 필요

- copy

  ```python
  list = [[0] * 3] * 3
  list1[0][0] = 1
  print(list) # => [[1,0,0],[1,0,0],[1,0,0]]
  
  arr1 = [[1,2],[3,4]]
  arr2 = [arr[0]]
  arr1[0][0] = 100
  print(arr1) # => [[100,2], [3,4]]
  print(arr2) # => [[100,2]]
  
  # => 방법
  list2 = [[0] * 3 for _ in range(3)]
  list2[0][0] = 1
  print(list2) # => [[1,0,0],[0,0,0],[0,0,0]]
  ```

#### 2.1 2차원 배열의 접근

- 배열 순회 : n X m 배열의 n*m개의 모든 원소 조사

- 행 우선 순회 : 행단위로 (2중 for문 이용 -> 바깥 : 행 안 : 열)

- 열 우선 순회 : 열단위로 (2중 for문 이용 -> 바깥 : 열 안 : 행)

- 지그재그 순회 : 인덱스 값이 짝수인 경우는 오른쪽으로 홀수인 경우는 왼쪽으로

  ```python
  arr = [[1, 2], [3, 4]]
  N = len(arr)
  for i in arr:
      if i % 2 == 0: # 짝수 : ------>
          for j in range(N):
              pass
      else:          # 홀수 : <-------
          for j in range(N-1, -1, -1):
              pass
  ```

- 델타를 이용한 2차 배열 탐색 : 2차 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색.

  (탐색할 행렬, 기준행, 열(ex. 상하좌우) 을 정해야한다)

- 대각선 순회

  ```python
  N, M = len(arr), len(arr[0])
  for diag in range(0, N + M -1):
      x = 0 if diag < M else (diag - M + 1)
      y = diag if diag < M else M-1
  
      while x < N and y >= 0:
          print('%2d ' % arr[x][y], end='')
          x += 1
          y -= 1
  ```

  

#### 2.2 활용

- 전치 행렬 : 대각선을 기준으로 대칭되게 변경.

  ```python
  arr = [[1,2,3],[4,5,6],[7,8,9]] # 3*3 행렬
  
  for i in range(3):
      for j in range(3):
          if i < j:
              arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
  ```



### 3. 비트연산자

- `&` : 비트 단위로 AND 연산, `|` : 비트 단위로 OR 연산

  `<<` : 피연산자의 비트 열을 왼쪽으로 이동, `>>` : 피연산자의 비트 열을 오른쪽으로 이동

- `<<` 연산자 : 1<< n -> 원소가 n개일 경우의 모든 부분집합의 수를 의미

- `&` 연산자: i & (1<<j) -> i의 j번째 비트가 1인지 아닌지를 리턴



### 4. 검색

- 순차 검색 - 단순, 직관, 비효율

  - 정렬되어 있지 않은 경우

    평균 비교 회수 : (n+1)/2

    시간 복잡도 : O(n)

  - 정렬되어 있는 경우

    평균 비교 회수 : 검색 실패시 반으로 준다.

    시간 복잡도 : O(n)

- 이진 검색(Binary Search)

  - 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 다시 진행하는 방법

- 선택정렬

  - 가장 작은 값의 원서부터 차례대로 선택하여 위치를 교환

    ```python
    arr = [64, 25, 10, 22, 11]
    n = len(arr)
    
    for i in range(n - 1):
        minIdx = i
        for j in range(i + 1, n):
            if arr[minIdx] > arr[j]:
                minIdx = j
        arr[i], arr[minIdx] = arr[minIdx], arr[i]
    
    print(arr)
    ```

- 셀렉션 알고리즘(Selection Algorithm)

  - 저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법을 셀렉션 알고리즘이라 한다.
  - k가 비교적 작을때 유용하며 O(kn)의 수행시간을 필요로 한다.

