# ASP 응용

## 완전 검색 & 그리디

### 1. 반복과 재귀

* **반복(Iteration)** : 수행하는 작업이 완료될 때까지 반복

  * 반복 구조
    * 초기화  : 반복되는 명령문 실행하기 전에 (한 번만) 조건 검사에 사용할 변수 초기값 설정
    * 조건검사
    * 반복할 명령문 실행
    * 업데이트 : 무한 루프가 되지 않게 조건이 거짓이 되게 한다.

* **재귀(Recursion)** : 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법

  * **재귀적 알고리즘**

    * 문제 정의 필요 

      1. 하나 또는 그 이상의 기본 경우(basis case or rule)

         집합에 포함되어 있는 원소로 induction을 생성하기 위한 시드 역할

      2. 하나 또는 그 이상의 유도된 경우 (inductive case or rule)

         새로운 집합의 원소를 생성하기 위해 결합되어지는 방법

  * **재귀 함수(recursive function)**

    * 기본 부분과 유도 파트로 구성

    * 재귀함수 이용시 간결하고 이해가 쉽다

    * 메모리 및 속도에서 성능저하 발생 (반복 알고리즘보다 더 많은 메모리와 연산 필요)

    * 입력값 n이 커질수록 재귀 알고리즘은 반복에 비해 비효율적

      ```python
      # 팩토리얼 재귀함수 예시
      def fact(n):
          if n <= 1:      # Basic part
              return 1
          else:			# Inductive part
              return n * fact(n - 1)
      ```

* 반복과 재귀

  |               | 재귀                      | 반복                 |
  | ------------- | ------------------------- | -------------------- |
  | 종료          | 호출이 종료되는 기본 파트 | 반복문의 종료 조건   |
  | 수행 시간     | (상대적) 느림             | 빠름                 |
  | 메모리 공간   | (상대적) 많이 사용        | 적게 사용            |
  | 소스코드 길이 | 짧고 간결                 | 길다                 |
  | 소스코드 형태 | 선택 구조 (if ... else)   | 반복 구조(for,while) |
  | 무한 반복시   | 스택 오버플로우           | CPU를 반복해서 점유  |



### 2. 완전 검색 기법

* 모든 경우의 수를 생성/테스트히기 대문에 수행 속도는 느리지만, 해답을 찾을 확률이 높다.
* 이를 기반으로 `그리디 기법` 이나 `동적 계획법` 을 이용하여 효율적인 알고리즘을 찾을 수 있다.
* 우선 완전 검색으로 접근하여 해답 도출 후, 성능 개선을 위한 알고리즘 도출하는것 바람직.
* 순열, 조합, 부분집합과 같은 조합적 문제들과 연관



### 3 조합적 문제

#### 3.1 순열(Permutation)

* 서로 다른 것들 중 몇개를 뽑아서 한 줄로 나열하는 것 (`nPr`)

* **근사해** : 순서화된 요소들의 집합에서 (최소와 최대가 아닌) 최선의 방법을 찾는것

  ex) TSP (NP - Complete)

* 순열 생성 방법

  * **사전적 순서(Lexicographic-Order)** 

  * **최소 변경을 통한 방법** : 각각의 순열들은 이전의 상태에서 단지 두 개의 요소들 굔환을 통해 생성

    ```python
    # 재귀호출을 통한 순열 생성
    arr = [1, 2, 3, 4]
    N = len(arr)
    for i in range(N):
        arr[0], arr[i] = arr[i], arr[0]
        for j in range(1, N):
        	arr[1], arr[j] = arr[j], arr[1]
            arr[1], arr[j] = arr[j], arr[1]		# 배열 원상복구
        arr[0], arr[i] = arr[i], arr[0]		# 배열 원상복구
        
    # 재귀이용
    def perm(k,n):
        if k == n:
            print(arr)
            return
        for i in rang(k, N):
            arr[k], arr[i] = arr[i], arr[k]
            perm(k + 1, n)
            arr[k], arr[i] = arr[i], arr[k]	
    
    perm(0, N)
    ```

#### 3.2 부분집합

* 다수의 중요 알고리즘들이 원소들의 그룹에서 최적의 부분집합을 찾는것
* 생성방법
  * 바이너리 카운팅을 통한 사전적 순서
    * 부분집합의 가장 기본
    * 사전적 순서로 생성하기 위한 가장 간단한 방법



#### 3.3 조합

* 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것 (`nCr`)



### 4. 탐욕 알고리즘

> 최적해를 구하는 데 사용되는 근시안적인 방법.
>
> 여러 경우 중 하나를 선텍할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.
>
> 각 선택 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들이 모였을 시, 최적이라는 보장이 없다.